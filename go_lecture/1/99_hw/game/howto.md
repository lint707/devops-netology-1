Это детальное описание решения. Оно предназначено для людей без опыта, чтобы поменьше думать над алгоритмом, а преобразовывать описание в код.

Если у вас есть опыт разработки - вам лучше это не читать, иначе для вас роста не будет.

Далее идет много пустых строк чтобы вы случайно не увлеклись чтением если у вас есть опыт.

Даже если вы хотите делать по описанию - почитайте сначала спойлеры в основном ридми. Я буду на них в дальнейшем.

Затем прочитайте тесты - поймите в какой комнате что выводится.

После этого попробуйте нарисовать на бумажке схему с комнатами и что они выводят.

И если не щелкнет в голове - только после этого читайте текст ниже.

Текст решения описан чтобы не прямо-прямо он в код перекладывался, но так чтобы если чуть-чуть подумать - все было бы легко написать. Т.е. описан алгоритм решения, а не все решение на псевдо-коде.

Если у вас будут вопросы - конечно задавайте их мне, я отвечу-напраялю. Писать можно в любое время.




























Для начала полезные ссылки, чтобы додго не лазить по документации:
* https://golang.org/doc/effective_go - тут очень много всего основного по синтаксису
* https://github.com/golang/go/wiki/SliceTricks - это вам понадобится в предметах для удаления из слайса


Инак, мы можем работать с двумя функцями - handleCommand и initGame.

handleCommand является входной точкой в программу. В нее периходят данные которые надо обрабатывать и оттуда же вы выводим ответ.

На вход нам приходит общая команда, но по ней нам надо понять какую функцию выполнить. Для этого надо разбить команду по пробелу. Первым элементом получем команду и аргументы к ней.

Далее по этой комане надо выбрать функцию которая будет отвечать за ее обработку. Есть несколько вариантов - мапа с функциями и switch-case.

Пишем обработку всех функций, которые выводят "команда ХХХ не реализована". Теперь у нас есть скелет и надо реализовывать логику уже в него.

Начнем с первой команды, "осмотреться". 

Она выводит описание из комнаты "кухня". Значит у нас появляется первая сущность в программе, "комната". Это будет одноименная структура. Комнат будет много, значит нужен контейнер. Мапа подойдет - потому что удобно обращаться по ключу.

Но мы сразу начинаем с кухни, значит как-то понимаем к какой комнате обращаться - это где-то хранится. Что "это"? Состояние в какой комнате находится игрок. Значит у нас появляется второая структура, "игрок".

Игрок и комнаты инициализируются в initGame и являются глобальными переменнами (они конечно зло, но тут задание на другое).

Значит мы определяем структуры, определяем переменные этих типов, в initGame создаем комнаты и игрока, присваиваем в игрока что он находится в комнате.

Теперь в функции "осмотреться" я могу добраться до игрока и понять в какой комнате он находится.

Значит у меня есть данные, на основе которых я могу собраться ответ. Все эти даныне должны быть сосредоточены только в комнате, а в общих функциях по типу "осомтреться" не должно быть ничего касательно конкетной комнаты - только общая логика.

Какие данные нужные чтобы собрать ответ `ты находишься на кухне, на столе: чай, надо собрать рюкзак и идти в универ. можно пройти - коридор`? Разобьем их на части:

* `ты находишься на кухне` - некоторый приветственный текст
* `на столе: чай` - предметы комнаты (но вообще можно сделать и статичным текстом)
* `надо собрать рюкзак и идти в универ` - квест. эта штука динамическая
* `можно пройти - коридор` - собственно куда можно пройти

Чтобы лучше понять как такое организовать стоит посмотреть еще на ответ в комнате "комната": `на столе: ключи, конспекты, на стуле: рюкзак. можно пройти - коридор`. Разобьем по тем же частям:

* приветственного текста нету
* `на столе: ключи, конспекты, на стуле: рюкзак` - предметы комнаты, их можно подбирать и они у нас где-то сохраняются, а именно в "игроке" (там же мы храним в какой комнате находимся) и в зависимости от этого текст меняется
* квеста тут нету
* `можно пройти - коридор` - опять коридор :) но в коридоре будет больше комнат

Получается что ответ собирается у нас из 4-х блоков и в комнате у нас должны быть свойства, в которых хранятся эти данные. Несколько кусков там простые, рассматрим толкьо сложные:

* квест - он специфичен для конкретной комнаты и не может быть часть общего кода комнаты. Тут нам на помощь приходит поле-функция, в которую можно описать некоторую логику для конкретной комнаты. В этой логике мы должны проверять наличие рюкзака у игрока и в завимисости от этого менять текст.
* предметы - они у нас хранятся не просто одним списком, а с учетом хранилища (мебели), значит нам надо иметь хранилище с именем, внутри которого будут лежать уже предметы.

Теперь комбинируя эти данные можно собрать ответ для "осмотреться". 

Плюс-минут подобным образом будет строиться вся логика.

"идти" - из комнаты у нас есть проходы другие комнаты. Значит у нас где-то должен быть список или мапа с ними. Но есть нюанс - дверь в коридоре закрыта. Значит мапа подойдет лучше - потому что надо иметь не просто факт наличия, а еще открыто-закрыто.

"надеть" - тут логика на рюкзак завязана. можно прямо использовать его в условии внутри. Ну и проверки - есть он в комнате или нет. По выполнении команды у игрока в свойствах появляетя "рюкзак" и он сможет подбирать предметы. По коду тут только убрать предмет из комнаты и поменять свойство в игроке.

"взять" - подбираем предмет в рюкзак, если он есть. По коду аналогично рюкзаку - убираем предмет из комнаты и добавляем в список внутри игрока.

"применить" - тут логкиа с дверью и ключем. Хардкодить в общем коде конечно же нельзя. Значит надо как-то описать свойством внутри комнаты - те мы будем задавать это у конкртетной комнаты. По результату применения у нас должна открыться дверь на улицу. Можно сделать это прямо универстиалоьной логикой, а можно полем-функцией, которая при выполнении будет менять свойство двери на "открыто". Получается что у нас тут нужны в комнате данные "к чему применить", "что применить" и "триггер по применению".

