## Системы инициализации в Linux, какие бывают, приемущества наиболее популярной?
System V Init.
OpenRC.
Systemd.
Runinit.
Upstart.

#### СИСТЕМЫ ИНИЦИАЛИЗАЦИИ LINUX
За время развития операционных систем были созданы различные системы инициализации Linux. В разных дистрибутивах использовались разные системы. В этой статье мы рассмотрим лучшие системы инициализации, которые вы можете сейчас использовать. Мы начнем с более старых систем с меньшим функционалом, чтобы понять с чего все начиналось, затем подойдем к более новым, созданным в последнее время.

#### 1. SYSTEM V INIT
System V или SysV - это довольно старая, но до сих пор ещё популярная система инициализации Linux и Unix подобных операционных систем. Она была основой для создания многих других систем инициализации, а также первой коммерческой системой инициализации разработанной для Unix в AT&T. Она была разработана еще в 1983 году.
Почти все дистрибутивы Linux изначально использовали SysV. Исключением была только Gentoo, в которой использовалась собственная система инициализации и Slackware, с инициализацией в стиле BSD.

Основные возможности SysV:
Написание файлов запуска служб на bash;
Последовательный запуск служб;
Сортировка порядка запуска с помощью номеров в именах файлов;
Команды для запуска, остановки и проверки состояния служб.
Никакой параллельной загрузки, системы зависимостей, запуска по требованию и автоматического запуска здесь не было и в помине.

С момента ее разработки прошло много лет и из-за некоторых недостатков были разработаны другие системы для ее замены, они хоть и имели новые функции и были более эффективны, но они были по-прежнему совместимы с SysV.

#### 2. OPENRC
OpenRC - это система инициализации Linux и Unix подобных операционных систем совместимая с Sys V Init и поддерживающая систему зависимостей во время запуска. Она приносит некоторые улучшения в SysV, и как и другие системы инициализации Linux, совместима с ней, но вы должны иметь в виду, что OpenRC не заменяет полностью файл /sbin/init. Эта система инициализации используется в Gentoo и дистрибутивах BSD.

Кроме стандартных возможностей SysV, здесь поддерживается также:
Поддержка зависимостей служб;
Поддержка параллельного запуска служб;
Поддерживает настройку в одном отдельном файле;
Работает как демон;
По сравнению с SysV тут появилось много новых возможностей, но все еще не все те, что нужны для оптимальной работы системы.

#### 3. SYSTEMD
Systemd - это новая система инициализации Linux. Она была введена по умолчанию в Fedora 15, а сейчас используется почти во всех популярных Linux дистрибутивах. Это не только инициализирующий процесс, поддерживающий огромное количество возможностей, но и набор инструментов для управления службами и этими возможностями из системы. Основная цель - иметь полный контроль над всеми процессами во время их запуска и на протяжении всего выполнения.
Systemd очень сильно отличается от всех существующих систем инициализации, тем как она работает с сервисами, и даже конфигурационными файлами сервисов. Совместимости со скриптами SysV нет, их нужно преобразовать в linux systemd unit файлы.

Вот ее основные особенности:
Понятный, простой и эффективный дизайн;
Параллельная загрузка служб на основе зависимостей;
Поддерживается завершение дополнительных процессов;
Поддерживается собственный журнал с помощью journald;
Поддерживается планирование заданий с помощью таймеров Systemd;
Поддерживается управление сетью с помощью networkd;
Для управления DNS используется systemd-resolved;
Хранение журналов в бинарных файлах;
Сохранение состояния сервисов linux systemd для возможного восстановления;
Улучшенная интеграция с Gnome;
Запуск сервисов по требованию;

#### 4. RUNINIT
Runinit - это кроссплатформенная система инициализации, которая может работать в GNU Linux, Solaris, BSD и MacOS. Это отличная альтернатива для SysV с поддержкой мониторинга состояния служб.

Здесь есть некоторые интересные особенности, которых нет в других системах инициализации:
Полный контроль сервисов, каждый сервис привязывается к своему каталогу;
Надежное средство журналирования и ротации логов;
Быстрая система загрузки и выключения;
Портативность;
Легкое создание файлов конфигурации служб;
Небольшое количество кода системы инициализации.

#### 5. UPSTART
Upstart - это система инициализации на основе событий, разработанная в Canonical и призванная заменять SysV. Она может запускать системные службы, выполнять над ними различные задачи, инспектировать их во время выполнения, а также выполнять нужные действия в ответ на события в системе.

Это гибридная система инициализации, она использует как SysV скрипты запуска, так и файлы служб Systemd. Вот ее самые заметные особенности:
Изначально разработанная для Ubuntu, но может использоваться и в других дистрибутивах;
Запуск и остановка служб на основе событий;
Генерация событий во время запуска и остановки служб;
События могут быть отправлены обычными процессами;
Связь с процессом инициализации через DBus;
Пользователи могут запускать и останавливать свои процессы;
Перезапуск служб, которые неожиданно завершились;
Параллельная загрузка сервисов;
Автоматический перезапуск служб;
Большинство ее возможностей работают благодаря интеграции с системой инициализации Systemd. В последнее время всё меньше используются скрипты SysV init и всё больше применяются юнит файлы Systemd. Рано или поздно Systemd вытеснит и полностью заменит Upstart в Ubuntu.

ВЫВОДЫ
Как я уже говорил, система инициализации запускает и управляет всеми другими процессами в системе Linux. SysV до недавнего времени была основной системой инициализации в большинстве дистрибутивов Linux, но из-за некоторых своих недостатков для нее было разработано несколько замен, в том числе Systemd.

===================================================================
## Какие потоки ввода - вывода существуют в Linux, их нумерация?
Стандартный ввод при работе пользователя в терминале передается через клавиатуру.
Стандартный вывод и стандартная ошибка отображаются на дисплее терминала пользователя в виде текста.
Ввод и вывод распределяется между тремя стандартными потоками: </br>
0 — стандартный ввод (stdin),

1 — стандартный вывод (stdout),

2 — стандартный поток сообщений об ошибках (stderr).
Ссылаться на эти потоки можно по их файловым дескрипторам. 0, 1 и 2 — это и есть такие дескрипторы.

===================================================================
## Как перенаправить поток вывода ошибок в стандартный вывод, зачем это может пригодиться?
Чтобы перенаправить стандартный поток ошибок в файл, используйте оператор `2>`. Укажите после имени команды оператор `2>`, а затем имя файла, который будет служить приемником ошибок выполнения программы. Например, чтобы записать ошибки выполнения программы programma в файл programma.errors, введите:
`$ programma 2> programma.errors [Enter]`

Чтобы добавить стандартный поток ошибок в уже существующий файл, используйте оператор `»` вместо `>`.
`$ programma 2>> programma.errors [Enter]`

Чтобы перенаправить в один и тот же файл поток вывода и поток ошибок, используйте оператор `SPMamp;>`.
`$ programma &> result_with_errors [Enter]`
Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
&>file или >&file — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1.

===================================================================
## Есть приложение, которое пишет лог -файл, он занял почти все свободное место на диске. Приложение останавливать нельзя, каким образом правильно освободить место на диске?
    
Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). </br>
    Терминал 1. Создание файла и настройка логирования:
    ```
    vagrant@vagrant:~/tping$ echo " " > ping.log
    vagrant@vagrant:~/tping$ exec 5> ping.log
    vagrant@vagrant:~/tping$ ping 127.0.0.1 >&5
    ```
    Терминал 2. Удаление файла:
    ```
    vagrant@vagrant:~/tping$ rm ping.log
    vagrant@vagrant:~/tping$ ls -l
    total 0
    ```
    Терминал 2. Поиск: 
    ```
    vagrant@vagrant:~/tping$ lsof | grep ping
    bash      1358                        vagrant  cwd       DIR              253,0     4096    1181766 /home/vagrant/tping
    bash      1358                        vagrant    5w      REG              253,0    14904    1181768 /home/vagrant/tping/ping.log (deleted)
    vagrant@vagrant:~/tping$ sudo lsof -p 1358 | grep ping
    bash    1358 vagrant  cwd    DIR  253,0     4096 1181766 /home/vagrant/tping
    bash    1358 vagrant    5w   REG  253,0    14904 1181768 /home/vagrant/tping/ping.log (deleted)
    ```
    Терминал 2. Очистка:
    ```
    vagrant@vagrant:~/tping$ cat /dev/null | sudo tee /proc/1358/fd/5
    vagrant@vagrant:~/tping$ sudo lsof -p 1358 | grep ping
    bash    1358 vagrant  cwd    DIR  253,0     4096 1181766 /home/vagrant/tping
    bash    1358 vagrant    5w   REG  253,0        0 1181768 /home/vagrant/tping/ping.log (deleted)
    vagrant@vagrant:~/tping$
    ```

===================================================================
## Что такое файловый дескриптор.
Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом. 

Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux. Открыли 100 файлов — где-то в ядре появились 100 записей, представленных целыми числами.

Как файлы получают дескрипторы
Обычно файловые дескрипторы выделяются последовательно. Есть пул свободных номеров. Когда вы создаете новый файл или открываете существующий, ему присваивается номер. Следующий файл получает очередной номер — например, 101, 102, 103 и так далее. 
Дескриптор для каждого процесса является уникальным. Но есть три жестко закрепленных индекса — это первые три номера (0, 1, 2).
Когда вы завершаете работу с файлом, присвоенный ему дескриптор освобождается и возвращается в пул свободных номеров. Он снова доступен для выделения под новый файл. 

===================================================================
## Какой утилитой можно посмотреть файлы связанные с определенным потоком ввода-вывода?
Для того, чтобы получить список всех открытых в Linux дескрипторов, можно воспользоваться командой lsof
У этой команды есть множество ключей, рассмотрим самые важные.

-p Позволяет указать ID процесса.
-d Позволяет указать номер дескриптора, о котором надо получить сведения.

Для того, чтобы узнать PID текущего процесса, можно использовать специальную переменную окружения $$, в которую оболочка записывает текущий PID.

Ключ -a используется для выполнения операции логического И над результатами, возвращёнными благодаря использованию двух других ключей:

lsof -a -p $$ -d 0,1,2

===================================================================
## Что такое интернет сокет в Linux?
Socket (розетка) - Сокет - это абстракция сетевого взаимодействия в операционной системе Linux. Каждому сокету соответствует пара IP-адрес + номер порта.
Поскольку сокет является только лишь абстракцией, то связка IP-адрес + номер порта - это уже имплементация в ОС. Верное название этой имплементации - "Интернет сокет". Абстракция используется для того, чтобы операционная система могла работать с любым типом канала передачи данных.
Именно поэтому в ОС Linux Интернет сокет - это дескриптор, с которым система работает как с файлом. Типов сокетов, конечно же, намного больше. В ядре ОС Linux сокеты представлены тремя основными структурами:
struct socket - представление сокета BSD, того вида сокета, который стал основой для современных "Интернет сокетов";
struct sock - собственная оболочка, которая в Linux называется "INET socket";
struct sk_buff - "хранилище" данных, которые передает или получает сокет;

A сетевой сокет - это программная структура в сетевом узле компьютерная сеть , которая служит конечной точкой для отправки и получения данных по сети. Структура и свойства сокета определяются интерфейсом прикладного программирования (API) для сетевой архитектуры. Сокеты создаются только во время существования процесса приложения, запущенного на узле.

Из-за стандартизации протоколов TCP / IP при разработке Интернета термин сетевой сокет чаще всего используется в контексте Internet Protocol Suite , поэтому его также часто называют Интернет-сокетом . В этом контексте сокет внешне идентифицируется для других хостов по его адресу сокета , который является триадой из транспортного протокола , IP-адреса и . номер порта .

Термин сокет также используется для конечной точки программного обеспечения внутреннего межпроцессного взаимодействия (IPC), которое часто использует тот же API, что и сетевой сокет.Википедия  site:wiki5.ru

===================================================================
## Какая встроенная утилита есть в Linux для ротации логов, какой тип ротации бывает?
Утилита Logrotate предназначена для автоматизации обработки журналов. Она может выполнять с ними необходимые действия в зависимости от определенных условий и правил соответствия. Например, можно сжимать журналы в архив или отправлять на другой сервер когда они достигают определенного размера, возраста, или других параметров.
Опции:
weekly — регулярность ротации — ротация раз в неделю, возможна иная периодичность: daily, monthly;
compress — сжимать копию лога, по умолчанию для этого используется архиватор gzip, хотя можно прицепить и какой-то внешний;
delaycompress — сжимать последнюю копию только при следующей ротации, это удобно, потому что самые свежие логи не придётся разархивировать;
notifempty — не ротировать лог, если он пуст;
missingok — не проверять наличие файла (если лога нет, то ничего страшного);
rotate 24 — количество сохраняемых копий, мне вот хватает данных и за последние полгода
mail mail@example.com — отправляет свежую созданную копию на указанный e-mail, не всегда практично при больших размерах логов
create 644 root root — сразу после ротации старого создать новый пустой лог, указываются, соответственно, права доступа, юзер и группа файла
postrotate/endscript – действие, выполняемое после ротации логов, в нашем случае перезагрузка httpd сервера;
size – можно указать размер вместо weekly, например size 10M – в этом случае лог будет писаться в файл до того момента пока он не превысит 10-мегабайт.

===================================================================
## Что такое systemd unit, для чего он нужен, в каком каталоге создают файлы юнитов?
systemd использует юнит-файлы для конфигурации и управления системными ресурсами, такими, как процессы и ваша файловая система. Благодаря этим файлам вы можете использовать systemd для конфигурации вашей системы в соответствии с вашими пожеланиями.
Юнит-файлы в вашей системе описывают параметры системы инициализации systemd, которая используется в процессе ее загрузки и работы. Каждый из файлов соответствует отдельному действию или компоненту - или юниту (unit) в терминологии systemd. Каждый из юнит-файлов является простым текстовым файлом с описанием юнита, его назначения, операций, которые должны быть выполнены до и после его запуска, а также других деталей.
Например, службы (.service), точки монтирования (.mount), устройства (.device) или сокеты (.socket).
Юнит-файлы могут храниться в нескольких различных директориях вашей файловой системы. systemd осуществляет поиск системных юнит-файлов в директориях в следующей последовательности:
/etc/systemd/system
/run/systemd/system
/usr/lib/systemd/system


https://wiki.archlinux.org/title/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)
http://rus-linux.net/MyLDP/boot/systemd_2_getting_a_grip_on_units.html
https://linux-notes.org/pishem-systemd-unit-fajl/

===================================================================
## Что такое маска подсети, зачем она нужна?
Маска подсети(network mask, subnet mask) — битовая маска (bitmask) для определения по IP-адресу адреса подсети и адреса узла (хоста, компьютера, устройства) этой подсети. В отличие от IP-адреса маска подсети не является частью IP-пакета. Благодаря маске можно узнать, какая часть IP-адреса узла сети относится к адресу сети, а какая — к адресу самого узла в этой сети.

Маска подсети используется протоколом TCP/IP для определения того, находится ли хост в локальной подсети или в удаленной сети.
Она позволяет определить, кто находится с вами в одной (под)сети, а кто не в ней. Компьютеры, находящиеся внутри одной сети, обмениваются данными между собой напрямую, например, в локальной. Но если нужно выйти в глобальную паутину, то запрос идет уже через роутер — шлюз по умолчанию.

https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D0%BA%D0%B0_%D0%BF%D0%BE%D0%B4%D1%81%D0%B5%D1%82%D0%B8
https://anisim.org/articles/maska-podseti/

===================================================================
## Какой размер адресного пространства ipv4, зачем был создан ipv6
IP-адрес (v4) состоит из 32-бит: всего теоретически IPv4-адресов может быть около 4 млрд.
IPv6: 128 бит: Кратное увеличение адресного пространства.

===================================================================
## Что такое DNS, например есть типы записи MX, TXT, PTR, для чего они нужны?
DNS (англ. Domain Name System «система доменных имён») — компьютерная распределительная система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене (SRV-запись).

Распределённая база данных DNS поддерживается с помощью иерархии DNS-серверов, взаимодействующих по определённому протоколу.

Основой DNS является представление об иерархической структуре имени и зонах. Каждый сервер, отвечающий за имя, может передать ответственность за дальнейшую часть домена другому серверу (с административной точки зрения — другой организации или человеку), что позволяет возложить ответственность за актуальность информации на серверы различных организаций (людей), отвечающих только за «свою» часть доменного имени.
DNS обладает следующими характеристиками:

Распределённость администрирования. Ответственность за разные части иерархической структуры несут разные люди или организации.
Распределённость хранения информации. Каждый узел сети в обязательном порядке должен хранить только те данные, которые входят в его зону ответственности, и (возможно) адреса корневых DNS-серверов.
Кэширование информации. Узел может хранить некоторое количество данных не из своей зоны ответственности для уменьшения нагрузки на сеть.
Иерархическая структура, в которой все узлы объединены в дерево, и каждый узел может или самостоятельно определять работу нижестоящих узлов, или делегировать (передавать) их другим узлам.
Резервирование. За хранение и обслуживание своих узлов (зон) отвечают (обычно) несколько серверов, разделённые как физически, так и логически, что обеспечивает сохранность данных и продолжение работы даже в случае сбоя одного из узлов.

- MX	Mail Exchanger	15	Адрес почтового шлюза для домена. Состоит из двух частей — приоритета (чем число больше, тем ниже приоритет), и адреса узла	критически важна для SMTP-протокола, основа маршрутизации почты в Интернете. Почтовый обменник указывает сервер(ы) обмена почтой для данного домена.
- PTR	pointer	12	Соответствие адреса имени — обратное соответствие для A и AAAA.	широко используется для IPv4-адресов в домене in-addr.arpa, для IPv6 — в ip6.arpa. Так называемая «обратная запись». Она позволяет обратное разрешение (reverse resolving) IP-адреса в FQDN-хост.
- TXT	Text string	16	Запись произвольных двоичных данных, до 255 байт в размере	Sender Policy Framework, DNS-туннели и прочее. Текстовая запись DNS. Она интересна только тем, что может (и в современном мире — должна) содержать в себе SPF. SPF (Sender Policy Framework) — запись, позволяющая вам указать, какие сервера имеют право отправлять почту от имени вашего домена (представившись вашим сервером, либо с обратным адресом в вашем домене).

https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF%D1%8B_%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BD%D1%8B%D1%85_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B5%D0%B9_DNS
https://habr.com/ru/post/59417/

===================================================================
## Есть ли опыт написания простых скриптов на Bash, пример использования цикла FOR, в чем фича использования функции?

===================================================================
## Как создать пары ssh ключей в Linux, как ходить на хосты по ssh без ввода пароля.

===================================================================
## Что такое sudo, в каком файле или директории необходимо описывать параметры sudo для пользователей?
Команда sudo предоставляет возможность пользователям выполнять команды от имени суперпользователя root, либо других пользователей. Правила, используемые sudo для принятия решения о предоставлении доступа, находятся в файле /etc/sudoers

https://losst.ru/nastrojka-sudo-v-linux

===================================================================
## Что значает запись в sudo:
username      ALL=(ALL:ALL) NOPASSWD:ALL
Чтобы добавить пользователя и предоставить полные права sudo, добавьте следующую строку:
[username] ALL=(ALL:ALL) ALL	
Флаг NOPASSWD говорит, что не нужно запрашивать пароль при выполнении этого правила.
Также у этого файла должны быть определенные права доступа
chmod 644 /etc/sudoers.d/user
После этого можем логиниться в систему под учетной записью user, набирать
sudo -s
система пароль спрашивать не будет

https://server-gu.ru/sudo-no-passwd/

===================================================================
## Есть ли опыт использования sed/awk/less/head/tail для чего нужны эти утилиты?

===================================================================
## Как проверить доступность порта, слушает ли соединение сервер?
telnet - "telnet – ІР-адрес – порт" утилита, с помощью которой можно соединиться с удалённым портом любого компьютера и установить канал связи.

Утилита netstat позволяет увидеть открытые в системе порты, а также открытые на данный момент сетевые соединения. Для отображения максимально подробной информации надо использовать опции:
-l или --listening - посмотреть только прослушиваемые порты
-p или --program - показать имя программы и ее PID
-t или --tcp - показать tcp порты
-u или --udp показать udp порты
-n или --numeric показывать ip адреса в числовом виде

Утилита ss - это современная альтернатива для команды netstat. В отличие от netstat, которая берет информацию из каталога /proc, утилита ss напрямую связывается со специальной подсистемой ядра Linux, поэтому работает быстрее и её данные более точные, если вы хотите выполнить просмотр открытых портов это не имеет большого значения. Опции у неё такие же

Программа Nmap - мощный сетевой сканер, разработанный для сканирования и тестирования на проникновение удаленных узлов, но ничего не мешает направить его на локальный компьютер. Утилита позволяет не только посмотреть открытые порты, но и примерно определить какие сервисы их слушают и какие уязвимости у них есть. Программа Zenmap - это графический интерфейс для nmap.

https://losst.ru/kak-posmotret-otkrytye-porty-v-linux
https://habr.com/ru/company/ruvds/blog/417485/

===================================================================
## Как проверить, есть ли обращение клиента на порт TCP 22 сервера по определенному порту с определенного IP адреса?

===================================================================
## В каком файле Linux прописывается монтирование разделов?

===================================================================
## Был ли опыт конфигурирования Nginx, почему его используют как точку входа перед Backend?

===================================================================
## Можно ли удалить default.conf из Nginx, в чем его ключевая фишка?

===================================================================
## Где локально в Linux прописать соответствие IP - DNS, как это может помочь в отладке конфигурации Nginx?

===================================================================
## Где посмотреть сразу все настройки crontab разных пользователей в Linux?

===================================================================
## В чем принципиальное отличие виртуализации от контейнерезации?
Отличие виртуальной машины от контейнера. Главное отличие ― способ работы. При виртуализации создается полностью отдельная операционная система. При контейнеризации используется ядро операционной системы той машины, на которой открывается контейнер.

https://www.itc.by/kontejnery-i-virtualnye-mashiny-v-chem-klyuchevye-razlichiya/

===================================================================
## Что такое Namespace в Linux, какие типы неймспейсов бывают?
