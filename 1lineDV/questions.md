## Системы инициализации в Linux, какие бывают, приемущества наиболее популярной?
System V Init.
OpenRC.
Systemd.
Runinit.
Upstart.

#### СИСТЕМЫ ИНИЦИАЛИЗАЦИИ LINUX
За время развития операционных систем были созданы различные системы инициализации Linux. В разных дистрибутивах использовались разные системы. В этой статье мы рассмотрим лучшие системы инициализации, которые вы можете сейчас использовать. Мы начнем с более старых систем с меньшим функционалом, чтобы понять с чего все начиналось, затем подойдем к более новым, созданным в последнее время.

#### 1. SYSTEM V INIT
System V или SysV - это довольно старая, но до сих пор ещё популярная система инициализации Linux и Unix подобных операционных систем. Она была основой для создания многих других систем инициализации, а также первой коммерческой системой инициализации разработанной для Unix в AT&T. Она была разработана еще в 1983 году.
Почти все дистрибутивы Linux изначально использовали SysV. Исключением была только Gentoo, в которой использовалась собственная система инициализации и Slackware, с инициализацией в стиле BSD.

Основные возможности SysV:
Написание файлов запуска служб на bash;
Последовательный запуск служб;
Сортировка порядка запуска с помощью номеров в именах файлов;
Команды для запуска, остановки и проверки состояния служб.
Никакой параллельной загрузки, системы зависимостей, запуска по требованию и автоматического запуска здесь не было и в помине.

С момента ее разработки прошло много лет и из-за некоторых недостатков были разработаны другие системы для ее замены, они хоть и имели новые функции и были более эффективны, но они были по-прежнему совместимы с SysV.

#### 2. OPENRC
OpenRC - это система инициализации Linux и Unix подобных операционных систем совместимая с Sys V Init и поддерживающая систему зависимостей во время запуска. Она приносит некоторые улучшения в SysV, и как и другие системы инициализации Linux, совместима с ней, но вы должны иметь в виду, что OpenRC не заменяет полностью файл /sbin/init. Эта система инициализации используется в Gentoo и дистрибутивах BSD.

Кроме стандартных возможностей SysV, здесь поддерживается также:
Поддержка зависимостей служб;
Поддержка параллельного запуска служб;
Поддерживает настройку в одном отдельном файле;
Работает как демон;
По сравнению с SysV тут появилось много новых возможностей, но все еще не все те, что нужны для оптимальной работы системы.

#### 3. SYSTEMD
Systemd - это новая система инициализации Linux. Она была введена по умолчанию в Fedora 15, а сейчас используется почти во всех популярных Linux дистрибутивах. Это не только инициализирующий процесс, поддерживающий огромное количество возможностей, но и набор инструментов для управления службами и этими возможностями из системы. Основная цель - иметь полный контроль над всеми процессами во время их запуска и на протяжении всего выполнения.
Systemd очень сильно отличается от всех существующих систем инициализации, тем как она работает с сервисами, и даже конфигурационными файлами сервисов. Совместимости со скриптами SysV нет, их нужно преобразовать в linux systemd unit файлы.

Вот ее основные особенности:
Понятный, простой и эффективный дизайн;
Параллельная загрузка служб на основе зависимостей;
Поддерживается завершение дополнительных процессов;
Поддерживается собственный журнал с помощью journald;
Поддерживается планирование заданий с помощью таймеров Systemd;
Поддерживается управление сетью с помощью networkd;
Для управления DNS используется systemd-resolved;
Хранение журналов в бинарных файлах;
Сохранение состояния сервисов linux systemd для возможного восстановления;
Улучшенная интеграция с Gnome;
Запуск сервисов по требованию;

#### 4. RUNINIT
Runinit - это кроссплатформенная система инициализации, которая может работать в GNU Linux, Solaris, BSD и MacOS. Это отличная альтернатива для SysV с поддержкой мониторинга состояния служб.

Здесь есть некоторые интересные особенности, которых нет в других системах инициализации:
Полный контроль сервисов, каждый сервис привязывается к своему каталогу;
Надежное средство журналирования и ротации логов;
Быстрая система загрузки и выключения;
Портативность;
Легкое создание файлов конфигурации служб;
Небольшое количество кода системы инициализации.

#### 5. UPSTART
Upstart - это система инициализации на основе событий, разработанная в Canonical и призванная заменять SysV. Она может запускать системные службы, выполнять над ними различные задачи, инспектировать их во время выполнения, а также выполнять нужные действия в ответ на события в системе.

Это гибридная система инициализации, она использует как SysV скрипты запуска, так и файлы служб Systemd. Вот ее самые заметные особенности:
Изначально разработанная для Ubuntu, но может использоваться и в других дистрибутивах;
Запуск и остановка служб на основе событий;
Генерация событий во время запуска и остановки служб;
События могут быть отправлены обычными процессами;
Связь с процессом инициализации через DBus;
Пользователи могут запускать и останавливать свои процессы;
Перезапуск служб, которые неожиданно завершились;
Параллельная загрузка сервисов;
Автоматический перезапуск служб;
Большинство ее возможностей работают благодаря интеграции с системой инициализации Systemd. В последнее время всё меньше используются скрипты SysV init и всё больше применяются юнит файлы Systemd. Рано или поздно Systemd вытеснит и полностью заменит Upstart в Ubuntu.

ВЫВОДЫ
Как я уже говорил, система инициализации запускает и управляет всеми другими процессами в системе Linux. SysV до недавнего времени была основной системой инициализации в большинстве дистрибутивов Linux, но из-за некоторых своих недостатков для нее было разработано несколько замен, в том числе Systemd.

===================================================================
## Какие потоки ввода - вывода существуют в Linux, их нумерация?
Стандартный ввод при работе пользователя в терминале передается через клавиатуру.
Стандартный вывод и стандартная ошибка отображаются на дисплее терминала пользователя в виде текста.
Ввод и вывод распределяется между тремя стандартными потоками: </br>
0 — стандартный ввод (stdin),

1 — стандартный вывод (stdout),

2 — стандартный поток сообщений об ошибках (stderr).
Ссылаться на эти потоки можно по их файловым дескрипторам. 0, 1 и 2 — это и есть такие дескрипторы.

===================================================================
## Как перенаправить поток вывода ошибок в стандартный вывод, зачем это может пригодиться?
Чтобы перенаправить стандартный поток ошибок в файл, используйте оператор `2>`. Укажите после имени команды оператор `2>`, а затем имя файла, который будет служить приемником ошибок выполнения программы. Например, чтобы записать ошибки выполнения программы programma в файл programma.errors, введите:
`$ programma 2> programma.errors [Enter]`

Чтобы добавить стандартный поток ошибок в уже существующий файл, используйте оператор `»` вместо `>`.
`$ programma 2>> programma.errors [Enter]`

Чтобы перенаправить в один и тот же файл поток вывода и поток ошибок, используйте оператор `SPMamp;>`.
`$ programma &> result_with_errors [Enter]`
Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
&>file или >&file — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1.

===================================================================
## Есть приложение, которое пишет лог -файл, он занял почти все свободное место на диске. Приложение останавливать нельзя, каким образом правильно освободить место на диске?
    
Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). </br>
    Терминал 1. Создание файла и настройка логирования:
    ```
    vagrant@vagrant:~/tping$ echo " " > ping.log
    vagrant@vagrant:~/tping$ exec 5> ping.log
    vagrant@vagrant:~/tping$ ping 127.0.0.1 >&5
    ```
    Терминал 2. Удаление файла:
    ```
    vagrant@vagrant:~/tping$ rm ping.log
    vagrant@vagrant:~/tping$ ls -l
    total 0
    ```
    Терминал 2. Поиск: 
    ```
    vagrant@vagrant:~/tping$ lsof | grep ping
    bash      1358                        vagrant  cwd       DIR              253,0     4096    1181766 /home/vagrant/tping
    bash      1358                        vagrant    5w      REG              253,0    14904    1181768 /home/vagrant/tping/ping.log (deleted)
    vagrant@vagrant:~/tping$ sudo lsof -p 1358 | grep ping
    bash    1358 vagrant  cwd    DIR  253,0     4096 1181766 /home/vagrant/tping
    bash    1358 vagrant    5w   REG  253,0    14904 1181768 /home/vagrant/tping/ping.log (deleted)
    ```
    Терминал 2. Очистка:
    ```
    vagrant@vagrant:~/tping$ cat /dev/null | sudo tee /proc/1358/fd/5
    vagrant@vagrant:~/tping$ sudo lsof -p 1358 | grep ping
    bash    1358 vagrant  cwd    DIR  253,0     4096 1181766 /home/vagrant/tping
    bash    1358 vagrant    5w   REG  253,0        0 1181768 /home/vagrant/tping/ping.log (deleted)
    vagrant@vagrant:~/tping$
    ```

===================================================================
## Что такое файловый дескриптор.
Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом. 

Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux. Открыли 100 файлов — где-то в ядре появились 100 записей, представленных целыми числами.

Как файлы получают дескрипторы
Обычно файловые дескрипторы выделяются последовательно. Есть пул свободных номеров. Когда вы создаете новый файл или открываете существующий, ему присваивается номер. Следующий файл получает очередной номер — например, 101, 102, 103 и так далее. 
Дескриптор для каждого процесса является уникальным. Но есть три жестко закрепленных индекса — это первые три номера (0, 1, 2).
Когда вы завершаете работу с файлом, присвоенный ему дескриптор освобождается и возвращается в пул свободных номеров. Он снова доступен для выделения под новый файл. 

===================================================================
## Какой утилитой можно посмотреть файлы связанные с определенным потоком ввода-вывода?

===================================================================
## Что такое интернет сокет в Linux?
Socket (розетка) - Сокет - это абстракция сетевого взаимодействия в операционной системе Linux. Каждому сокету соответствует пара IP-адрес + номер порта.
Поскольку сокет является только лишь абстракцией, то связка IP-адрес + номер порта - это уже имплементация в ОС. Верное название этой имплементации - "Интернет сокет". Абстракция используется для того, чтобы операционная система могла работать с любым типом канала передачи данных.
Именно поэтому в ОС Linux Интернет сокет - это дескриптор, с которым система работает как с файлом. Типов сокетов, конечно же, намного больше. В ядре ОС Linux сокеты представлены тремя основными структурами:
struct socket - представление сокета BSD, того вида сокета, который стал основой для современных "Интернет сокетов";
struct sock - собственная оболочка, которая в Linux называется "INET socket";
struct sk_buff - "хранилище" данных, которые передает или получает сокет;

A сетевой сокет - это программная структура в сетевом узле компьютерная сеть , которая служит конечной точкой для отправки и получения данных по сети. Структура и свойства сокета определяются интерфейсом прикладного программирования (API) для сетевой архитектуры. Сокеты создаются только во время существования процесса приложения, запущенного на узле.

Из-за стандартизации протоколов TCP / IP при разработке Интернета термин сетевой сокет чаще всего используется в контексте Internet Protocol Suite , поэтому его также часто называют Интернет-сокетом . В этом контексте сокет внешне идентифицируется для других хостов по его адресу сокета , который является триадой из транспортного протокола , IP-адреса и . номер порта .

Термин сокет также используется для конечной точки программного обеспечения внутреннего межпроцессного взаимодействия (IPC), которое часто использует тот же API, что и сетевой сокет.Википедия  site:wiki5.ru

===================================================================
## Какая встроенная утилита есть в Linux для ротации логов, какой тип ротации бывает?

===================================================================
## Что такое systemd unit, для чего он нужен, в каком каталоге создают файлы юнитов?

===================================================================
## Что такое маска подсети, зачем она нужна?

===================================================================
## Какой размер адресного пространства ipv4, зачем был создан ipv6
IP-адрес (v4) состоит из 32-бит: всего теоретически IPv4-адресов может быть около 4 млрд.
IPv6: 128 бит: Кратное увеличение адресного пространства.

===================================================================
## Что такое DNS, например есть типы записи MX, TXT, PTR, для чего они нужны?

===================================================================
## Есть ли опыт написания простых скриптов на Bash, пример использования цикла FOR, в чем фича использования функции?

===================================================================
## Как создать пары ssh ключей в Linux, как ходить на хосты по ssh без ввода пароля.

===================================================================
## Что такое sudo, в каком файле или директории необходимо описывать параметры sudo для пользователей?

===================================================================
## Что значает запись в sudo:
username      ALL=(ALL:ALL) NOPASSWD:ALL

===================================================================
## Есть ли опыт использования sed/awk/less/head/tail для чего нужны эти утилиты?

===================================================================
## Как проверить доступность порта, слушает ли соеднение сервер?

===================================================================
## Как проверить, есть ли обращение клиента на порт TCP 22 сервера по определенному порту с определенного IP адреса?

===================================================================
## В каком файле Linux прописывается монтирование разделов?

===================================================================
## Был ли опыт конфигурирования Nginx, почему его используют как точку входа перед Backend?

===================================================================
## Можно ли удалить default.conf из Nginx, в чем его ключевая фишка?

===================================================================
## Где локально в Linux прописать соответствие IP - DNS, как это может помочь в отладке конфигурации Nginx?

===================================================================
## Где посмотреть сразу все настройки crontab разных пользователей в Linux?

===================================================================
## В чем принципиальное отличие виртуализации от контейнерезации?

===================================================================
## Что такое Namespace в Linux, какие типы неймспейсов бывают?
