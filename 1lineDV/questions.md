## Системы инициализации в Linux, какие бывают, приемущества наиболее популярной?
System V Init. 
OpenRC.
Systemd.
Runinit.
Upstart.

#### СИСТЕМЫ ИНИЦИАЛИЗАЦИИ LINUX
За время развития операционных систем были созданы различные системы инициализации Linux. В разных дистрибутивах использовались разные системы. В этой статье мы рассмотрим лучшие системы инициализации, которые вы можете сейчас использовать. Мы начнем с более старых систем с меньшим функционалом, чтобы понять с чего все начиналось, затем подойдем к более новым, созданным в последнее время.

#### 1. SYSTEM V INIT
System V или SysV - разработана в 1983 году, первая. комерческая система инициализации Unix в at&t.

Основные возможности SysV:
Написание файлов запуска служб на bash;
Последовательный запуск служб;
Сортировка порядка запуска с помощью номеров в именах файлов;
Команды для запуска, остановки и проверки состояния служб.
Никакой параллельной загрузки, системы зависимостей, запуска по требованию и автоматического запуска здесь не было и в помине.

> Почти все дистрибутивы Linux изначально использовали SysV. Исключением была только Gentoo, в которой использовалась собственная система инициализации и Slackware, с инициализацией в стиле BSD.

#### 2. OPENRC
OpenRC - это система инициализации Linux и Unix подобных операционных систем совместимая с Sys V Init и поддерживающая систему зависимостей во время запуска. Она приносит некоторые улучшения в SysV, и как и другие системы инициализации Linux, совместима с ней, но вы должны иметь в виду, что OpenRC не заменяет полностью файл /sbin/init. Эта система инициализации используется в Gentoo и дистрибутивах BSD.

Кроме стандартных возможностей SysV, здесь поддерживается также:
Поддержка зависимостей служб;
Поддержка параллельного запуска служб;
Поддерживает настройку в одном отдельном файле;
Работает как демон;
По сравнению с SysV тут появилось много новых возможностей, но все еще не все те, что нужны для оптимальной работы системы.

#### 3. SYSTEMD
Systemd - это новая система инициализации Linux. Она была введена по умолчанию в Fedora 15, а сейчас используется почти во всех популярных Linux дистрибутивах. Это не только инициализирующий процесс, поддерживающий огромное количество возможностей, но и набор инструментов для управления службами и этими возможностями из системы. Основная цель - иметь полный контроль над всеми процессами во время их запуска и на протяжении всего выполнения.
Systemd очень сильно отличается от всех существующих систем инициализации, тем как она работает с сервисами, и даже конфигурационными файлами сервисов. Совместимости со скриптами SysV нет, их нужно преобразовать в linux systemd unit файлы.

Вот ее основные особенности:
Понятный, простой и эффективный дизайн;
Параллельная загрузка служб на основе зависимостей;
Поддерживается завершение дополнительных процессов;
Поддерживается собственный журнал с помощью journald;
Поддерживается планирование заданий с помощью таймеров Systemd;
Поддерживается управление сетью с помощью networkd;
Для управления DNS используется systemd-resolved;
Хранение журналов в бинарных файлах;
Сохранение состояния сервисов linux systemd для возможного восстановления;
Улучшенная интеграция с Gnome;
Запуск сервисов по требованию;

#### 4. RUNINIT
Runinit - это кроссплатформенная система инициализации, которая может работать в GNU Linux, Solaris, BSD и MacOS. Это отличная альтернатива для SysV с поддержкой мониторинга состояния служб.

Здесь есть некоторые интересные особенности, которых нет в других системах инициализации:
Полный контроль сервисов, каждый сервис привязывается к своему каталогу;
Надежное средство журналирования и ротации логов;
Быстрая система загрузки и выключения;
Портативность;
Легкое создание файлов конфигурации служб;
Небольшое количество кода системы инициализации.

#### 5. UPSTART
Upstart - это система инициализации на основе событий, разработанная в Canonical и призванная заменять SysV. Она может запускать системные службы, выполнять над ними различные задачи, инспектировать их во время выполнения, а также выполнять нужные действия в ответ на события в системе.

Это гибридная система инициализации, она использует как SysV скрипты запуска, так и файлы служб Systemd. Вот ее самые заметные особенности:
Изначально разработанная для Ubuntu, но может использоваться и в других дистрибутивах;
Запуск и остановка служб на основе событий;
Генерация событий во время запуска и остановки служб;
События могут быть отправлены обычными процессами;
Связь с процессом инициализации через DBus;
Пользователи могут запускать и останавливать свои процессы;
Перезапуск служб, которые неожиданно завершились;
Параллельная загрузка сервисов;
Автоматический перезапуск служб;
Большинство ее возможностей работают благодаря интеграции с системой инициализации Systemd. В последнее время всё меньше используются скрипты SysV init и всё больше применяются юнит файлы Systemd. Рано или поздно Systemd вытеснит и полностью заменит Upstart в Ubuntu.

ВЫВОДЫ
Как я уже говорил, система инициализации запускает и управляет всеми другими процессами в системе Linux. SysV до недавнего времени была основной системой инициализации в большинстве дистрибутивов Linux, но из-за некоторых своих недостатков для нее было разработано несколько замен, в том числе Systemd.

===================================================================
## Какие потоки ввода - вывода существуют в Linux, их нумерация?
Стандартный ввод при работе пользователя в терминале передается через клавиатуру.
Стандартный вывод и стандартная ошибка отображаются на дисплее терминала пользователя в виде текста.
Ввод и вывод распределяется между тремя стандартными потоками: </br>
`0 — стандартный ввод (stdin),  `

`1 — стандартный вывод (stdout),  `

`2 — стандартный поток сообщений об ошибках (stderr).  `
Ссылаться на эти потоки можно по их файловым дескрипторам. 0, 1 и 2 — это и есть такие дескрипторы.  

===================================================================
## Как перенаправить поток вывода ошибок в стандартный вывод, зачем это может пригодиться?
Чтобы перенаправить стандартный поток ошибок в файл, используйте оператор `2>`. Укажите после имени команды оператор `2>`, а затем имя файла, который будет служить приемником ошибок выполнения программы. Например, чтобы записать ошибки выполнения программы programma в файл programma.errors, введите:
`$ programma 2> programma.errors [Enter]`

Чтобы добавить стандартный поток ошибок в уже существующий файл, используйте оператор `»` вместо `>`.
`$ programma 2>> programma.errors [Enter]`

Чтобы перенаправить в один и тот же файл поток вывода и поток ошибок, используйте оператор `SPMamp;>`.
`$ programma &> result_with_errors [Enter]`
Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
&>file или >&file — направить стандартный поток вывода и стандартный поток ошибок в файл. 

===================================================================
## Есть приложение, которое пишет лог -файл, он занял почти все свободное место на диске. Приложение останавливать нельзя, каким образом правильно освободить место на диске?
    
Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). </br>
Терминал 1. Создание файла и настройка логирования: </br>
```
    vagrant@vagrant:~/tping$ echo " " > ping.log
    vagrant@vagrant:~/tping$ exec 5> ping.log
    vagrant@vagrant:~/tping$ ping 127.0.0.1 >&5
```
Терминал 2. Удаление файла: </br>
```
    vagrant@vagrant:~/tping$ rm ping.log
    vagrant@vagrant:~/tping$ ls -l
    total 0
```
Терминал 2. Поиск:  </br>
```
    vagrant@vagrant:~/tping$ lsof | grep ping
    bash      1358                        vagrant  cwd       DIR              253,0     4096    1181766 /home/vagrant/tping
    bash      1358                        vagrant    5w      REG              253,0    14904    1181768 /home/vagrant/tping/ping.log (deleted)
    vagrant@vagrant:~/tping$ sudo lsof -p 1358 | grep ping
    bash    1358 vagrant  cwd    DIR  253,0     4096 1181766 /home/vagrant/tping
    bash    1358 vagrant    5w   REG  253,0    14904 1181768 /home/vagrant/tping/ping.log (deleted)
```
Терминал 2. Очистка: </br>
```
    vagrant@vagrant:~/tping$ cat /dev/null | sudo tee /proc/1358/fd/5
    vagrant@vagrant:~/tping$ sudo lsof -p 1358 | grep ping
    bash    1358 vagrant  cwd    DIR  253,0     4096 1181766 /home/vagrant/tping
    bash    1358 vagrant    5w   REG  253,0        0 1181768 /home/vagrant/tping/ping.log (deleted)
    vagrant@vagrant:~/tping$
```
 </br>
 
===================================================================
## Что такое файловый дескриптор.
Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом. 

Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux. Открыли 100 файлов — где-то в ядре появились 100 записей, представленных целыми числами.

Как файлы получают дескрипторы
Обычно файловые дескрипторы выделяются последовательно. Есть пул свободных номеров. Когда вы создаете новый файл или открываете существующий, ему присваивается номер. Следующий файл получает очередной номер — например, 101, 102, 103 и так далее. 
Дескриптор для каждого процесса является уникальным. Но есть три жестко закрепленных индекса — это первые три номера (0, 1, 2).
Когда вы завершаете работу с файлом, присвоенный ему дескриптор освобождается и возвращается в пул свободных номеров. Он снова доступен для выделения под новый файл. 

===================================================================
## Какой утилитой можно посмотреть файлы связанные с определенным потоком ввода-вывода?
Для того, чтобы получить список всех открытых в Linux дескрипторов, можно воспользоваться командой `lsof`
У этой команды есть множество ключей, рассмотрим самые важные.

`-p` Позволяет указать ID процесса.
`-d` Позволяет указать номер дескриптора, о котором надо получить сведения.

Для того, чтобы узнать `PID` текущего процесса, можно использовать специальную переменную окружения `$$`, в которую оболочка записывает текущий `PID`.

Ключ `-a` используется для выполнения операции логического И над результатами, возвращёнными благодаря использованию двух других ключей:

`lsof -a -p $$ -d 0,1,2`

===================================================================
## Что такое интернет сокет в Linux?
`Socket (розетка)` - Сокет - это абстракция сетевого взаимодействия в операционной системе Linux. Каждому сокету соответствует пара `IP-адрес + номер порта`.
Поскольку сокет является только лишь абстракцией, то связка `IP-адрес + номер порта` - это уже имплементация в ОС. Верное название этой имплементации - "Интернет сокет". Абстракция используется для того, чтобы операционная система могла работать с любым типом канала передачи данных.
Именно поэтому в ОС Linux Интернет сокет - это дескриптор, с которым система работает как с файлом. Типов сокетов, конечно же, намного больше. В ядре ОС Linux сокеты представлены тремя основными структурами:
`struct socket` - представление сокета BSD, того вида сокета, который стал основой для современных "Интернет сокетов";
`struct sock` - собственная оболочка, которая в Linux называется "INET socket";
`struct sk_buff` - "хранилище" данных, которые передает или получает сокет;

A сетевой сокет - это программная структура в сетевом узле компьютерная сеть , которая служит конечной точкой для отправки и получения данных по сети. Структура и свойства сокета определяются интерфейсом прикладного программирования (API) для сетевой архитектуры. Сокеты создаются только во время существования процесса приложения, запущенного на узле.

Из-за стандартизации протоколов TCP / IP при разработке Интернета термин сетевой сокет чаще всего используется в контексте Internet Protocol Suite , поэтому его также часто называют Интернет-сокетом . В этом контексте сокет внешне идентифицируется для других хостов по его адресу сокета , который является триадой из транспортного протокола , IP-адреса и . номер порта .

Термин сокет также используется для конечной точки программного обеспечения внутреннего межпроцессного взаимодействия (IPC), которое часто использует тот же API, что и сетевой сокет.Википедия  site:wiki5.ru

===================================================================
## Какая встроенная утилита есть в Linux для ротации логов, какой тип ротации бывает?
Утилита `Logrotate` предназначена для автоматизации обработки журналов. Она может выполнять с ними необходимые действия в зависимости от определенных условий и правил соответствия. Например, можно сжимать журналы в архив или отправлять на другой сервер когда они достигают определенного размера, возраста, или других параметров.
Опции:
`weekly` — регулярность ротации — ротация раз в неделю, возможна иная периодичность: daily, monthly;
`compress` — сжимать копию лога, по умолчанию для этого используется архиватор gzip, хотя можно прицепить и какой-то внешний;
`delaycompress` — сжимать последнюю копию только при следующей ротации, это удобно, потому что самые свежие логи не придётся разархивировать;
`notifempty` — не ротировать лог, если он пуст;
`missingok` — не проверять наличие файла (если лога нет, то ничего страшного);
`rotate 24` — количество сохраняемых копий, мне вот хватает данных и за последние полгода
`mail mail@example.com` — отправляет свежую созданную копию на указанный e-mail, не всегда практично при больших размерах логов
`create 644 root root` — сразу после ротации старого создать новый пустой лог, указываются, соответственно, права доступа, юзер и группа файла
`postrotate/endscript` – действие, выполняемое после ротации логов, в нашем случае перезагрузка httpd сервера;
`size` – можно указать размер вместо weekly, например size 10M – в этом случае лог будет писаться в файл до того момента пока он не превысит 10-мегабайт.

===================================================================
## Что такое systemd unit, для чего он нужен, в каком каталоге создают файлы юнитов?
`systemd` использует юнит-файлы для конфигурации и управления системными ресурсами, такими, как процессы и ваша файловая система. Благодаря этим файлам вы можете использовать `systemd` для конфигурации вашей системы в соответствии с вашими пожеланиями.
Юнит-файлы в вашей системе описывают параметры системы инициализации `systemd`, которая используется в процессе ее загрузки и работы. Каждый из файлов соответствует отдельному действию или компоненту - или `юниту (unit)` в терминологии `systemd`. Каждый из юнит-файлов является простым текстовым файлом с описанием юнита, его назначения, операций, которые должны быть выполнены до и после его запуска, а также других деталей.
Например: `службы (.service)`, `точки монтирования (.mount)`, `устройства (.device)` или `сокеты (.socket)`.
Юнит-файлы могут храниться в нескольких различных директориях вашей файловой системы. systemd осуществляет поиск системных юнит-файлов в директориях в следующей последовательности:
```
/etc/systemd/system
/run/systemd/system
/usr/lib/systemd/system
```

https://wiki.archlinux.org/title/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)
http://rus-linux.net/MyLDP/boot/systemd_2_getting_a_grip_on_units.html
https://linux-notes.org/pishem-systemd-unit-fajl/

===================================================================
## Что такое маска подсети, зачем она нужна?
`Маска подсети(network mask, subnet mask)` — битовая маска `(bitmask)` для определения по `IP`-адресу адреса подсети и адреса узла (хоста, компьютера, устройства) этой подсети. В отличие от IP-адреса маска подсети не является частью IP-пакета. Благодаря маске можно узнать, какая часть IP-адреса узла сети относится к адресу сети, а какая — к адресу самого узла в этой сети.

Маска подсети используется протоколом TCP/IP для определения того, находится ли хост в локальной подсети или в удаленной сети.
Она позволяет определить, кто находится с вами в одной (под)сети, а кто не в ней. Компьютеры, находящиеся внутри одной сети, обмениваются данными между собой напрямую, например, в локальной. Но если нужно выйти в глобальную паутину, то запрос идет уже через роутер — шлюз по умолчанию.

https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D0%BA%D0%B0_%D0%BF%D0%BE%D0%B4%D1%81%D0%B5%D1%82%D0%B8
https://anisim.org/articles/maska-podseti/

===================================================================
## Какой размер адресного пространства ipv4, зачем был создан ipv6
IP-адрес (v4) состоит из 32-бит: всего теоретически IPv4-адресов может быть около 4 млрд.
IPv6: 128 бит: Кратное увеличение адресного пространства.

===================================================================
## Что такое DNS, например есть типы записи MX, TXT, PTR, для чего они нужны?
`DNS` (англ. Domain Name System «система доменных имён») — компьютерная распределительная система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене `(SRV-запись)`.
Распределённая база данных `DNS` поддерживается с помощью иерархии `DNS-серверов`, взаимодействующих по определённому протоколу.
Основой `DNS` является представление об иерархической структуре имени и зонах. Каждый сервер, отвечающий за имя, может передать ответственность за дальнейшую часть домена другому серверу (с административной точки зрения — другой организации или человеку), что позволяет возложить ответственность за актуальность информации на серверы различных организаций (людей), отвечающих только за «свою» часть доменного имени.
DNS обладает следующими характеристиками:

Распределённость администрирования. Ответственность за разные части иерархической структуры несут разные люди или организации.
Распределённость хранения информации. Каждый узел сети в обязательном порядке должен хранить только те данные, которые входят в его зону ответственности, и (возможно) адреса корневых DNS-серверов.
Кэширование информации. Узел может хранить некоторое количество данных не из своей зоны ответственности для уменьшения нагрузки на сеть.
Иерархическая структура, в которой все узлы объединены в дерево, и каждый узел может или самостоятельно определять работу нижестоящих узлов, или делегировать (передавать) их другим узлам.
Резервирование. За хранение и обслуживание своих узлов (зон) отвечают (обычно) несколько серверов, разделённые как физически, так и логически, что обеспечивает сохранность данных и продолжение работы даже в случае сбоя одного из узлов.

- `MX`	`Mail Exchanger`	15	Адрес почтового шлюза для домена. Состоит из двух частей — приоритета (чем число больше, тем ниже приоритет), и адреса узла	критически важна для `SMTP`-протокола, основа маршрутизации почты в Интернете. Почтовый обменник указывает сервер(ы) обмена почтой для данного домена.
- `PTR`	`pointer`	12	Соответствие адреса имени — обратное соответствие для A и AAAA.	широко используется для IPv4-адресов в домене in-addr.arpa, для IPv6 — в ip6.arpa. Так называемая «обратная запись». Она позволяет обратное разрешение (reverse resolving) IP-адреса в FQDN-хост.
- `TXT`	`Text string`	16	Запись произвольных двоичных данных, до 255 байт в размере	Sender Policy Framework, DNS-туннели и прочее. Текстовая запись DNS. Она интересна только тем, что может (и в современном мире — должна) содержать в себе `SPF`. 
`SPF (Sender Policy Framework)` — запись, позволяющая вам указать, какие сервера имеют право отправлять почту от имени вашего домена (представившись вашим сервером, либо с обратным адресом в вашем домене).

https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF%D1%8B_%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BD%D1%8B%D1%85_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B5%D0%B9_DNS
https://habr.com/ru/post/59417/

===================================================================
## Есть ли опыт написания простых скриптов на Bash, пример использования цикла FOR, в чем фича использования функции?

Циклы `for`
Оболочка `bash` поддерживает циклы `for`, которые позволяют организовывать перебор последовательностей значений. Вот какова базовая структура таких циклов:
```
for var in list
do
команды
done
```
Пожалуй, самый простой пример цикла for в bash-скриптах — это перебор списка простых значений:
```
#!/bin/bash
for var in first second third fourth fifth
do
echo The  $var item
done
```
В списке, использованном при инициализации цикла `for`, могут содержаться не только простые строки, состоящие из одного слова, но и целые фразы, в которые входят несколько слов и знаков препинания. 


===================================================================
## Как создать пары ssh ключей в Linux, как ходить на хосты по ssh без ввода пароля.
Первый шаг — создание пары ключей на клиентской системе (обычно на вашем компьютере):
```
ssh-keygen -t rsa -b 4096 -C "your_email@example.com" -f ~/.ssh/{{filename}}
```
Второй Шаг — Копирование открытого ключа на сервер Ubuntu
Копирование открытого ключа с помощью утилиты ssh-copy-id
```
ssh-copy-id username@remote_host
```
Третий Шаг — Аутентификация на вашем сервере Ubuntu с помощью ключей SSH
```
ssh username@remote_host
```
```
Используемые опции:
-f ~/.ssh/{{filename}}
Путь к файлу.
-b bits
Определяет число бит в ключе при его создании. Минимум это 512 бит. Как правило, 2048 бит считается достаточным. По умолчанию используется 2048 бит.
-c
Запрашивает изменение комментария в файлах приватных и публичных ключей. Операция поддерживается только для RSA1-ключей. Программа предложит указать файл содержащей приватный ключ, спросит ключевое слово, если таковое имеется, и новый комментарий.
-е
Эта опция позволяет прочитать приватный или публичный OpenSSH-файл ключа и распечатать его в "SECSH Public Key File Format" в стандартный вывод. Также, данная опция позволяет экспортировать ключи для использования с некоторыми коммерческими реализациями SSH. -f filename Определяет имя файла для файла ключа.
-i
Эта опция считывает не зашифрованный SSH2-совместимый приватный (или публичный) файл ключа и распечатывает OpenSSH-совместимый приватный (или публичный) ключ в стандартный вывод. Также, ssh-keygen считывает "SECSH Public Key File Format". Данная опция позволяет импортировать ключи из некоторых коммерческих реализаций SSH.
-l
Показывает распечатку указанного приватного или публичного ключа. Также поддерживаются приватные RSA1-ключи. Для RSA- и DSA-ключей ssh-keygen предпримет попытку найти соответствующие публичные ключи и их отпечатки.
-p
Запрашивает изменение ключевой фразы приватного ключа вместо создания нового приватного ключа. Программа предложит указать имя файла содержащего приватный ключ, старую ключевую фразу и, дважды, новую ключевую фразу.
-q
Тихий ssh-keygen. Используется в работе /etc/rc при создании нового ключа.
-y
Эта опция читает приватный OpenSSH-формат файла и печатает публичный ключ OpenSSH в стандартный вывод.
-t type
Определяет тип создаваемого ключа. Допустимыми являются значения "rsa1", для протокола версии 1, и "rsa1" или "dsa", для протокола версии 2.
-В
Этот параметр отображает "bubblebabble" дайджест заданного файла публичного или приватного ключа.
-C comment
Обеспечивает ввод нового комментария.
-D reader
Копировать сохранённый публичный RSA-ключ со smartcard в устройстве reader.
-N new_passphrase
Обеспечивает ввод новой ключевой фразы.
-P passphrase
Обеспечивает ввод (старой) ключевой фразы.
-D reader
Копировать публичный RSA-ключ на smartcard в устройстве reader.

```
===================================================================
## Что такое sudo, в каком файле или директории необходимо описывать параметры sudo для пользователей?
Команда `sudo` предоставляет возможность пользователям выполнять команды от имени суперпользователя root, либо других пользователей. Правила, используемые sudo для принятия решения о предоставлении доступа, находятся в файле `/etc/sudoers`

https://losst.ru/nastrojka-sudo-v-linux

===================================================================
## Что значает запись в sudo:
`username      ALL=(ALL:ALL) NOPASSWD:ALL`
Чтобы добавить пользователя и предоставить полные права `sudo`, добавьте следующую строку:
`[username] ALL=(ALL:ALL) ALL	`
Флаг `NOPASSWD` говорит, что не нужно запрашивать пароль при выполнении этого правила.
Также у этого файла должны быть определенные права доступа
`chmod 644 /etc/sudoers.d/user`
После этого можем логиниться в систему под учетной записью `user`, набирать
`sudo -s`
система пароль спрашивать не будет

https://server-gu.ru/sudo-no-passwd/

===================================================================
## Есть ли опыт использования sed/awk/less/head/tail для чего нужны эти утилиты?
В основном использовал `vim/cat/head/tail`.
`sed` - Утилиту sed называют потоковым текстовым редактором. В интерактивных текстовых редакторах, наподобие nano. 
https://habr.com/ru/company/ruvds/blog/327530/
`awk` - Утилита awk, или точнее GNU awk, в сравнении с sed, выводит обработку потоков данных на более высокий уровень.
https://habr.com/ru/company/ruvds/blog/327754/
`less` — программа для текстовых терминалов UNIX-подобных систем, используемая для просмотра (но не изменения) содержимого текстовых файлов на экране.
https://ru.wikipedia.org/wiki/Less
`head` - Команда head выводит начальные строки (по умолчанию — 10)
`tail` - Команда tail выводит последние строки (по умолчанию — 10)

===================================================================
## Как проверить доступность порта, слушает ли соединение сервер?
`telnet - "telnet – ІР-адрес – порт"` утилита, с помощью которой можно соединиться с удалённым портом любого компьютера и установить канал связи.

Утилита `netstat `позволяет увидеть открытые в системе порты, а также открытые на данный момент сетевые соединения. Для отображения максимально подробной информации надо использовать опции:
`-l` или `--listening` - посмотреть только прослушиваемые порты
`-p` или `--program` - показать имя программы и ее PID
`-t` или `--tcp` - показать tcp порты
`-u` или `--udp` показать udp порты
`-n` или `--numeric` показывать ip адреса в числовом виде

Утилита `ss` - это современная альтернатива для команды `netstat`. В отличие от `netstat`, которая берет информацию из каталога `/proc`, утилита `ss` напрямую связывается со специальной подсистемой ядра Linux, поэтому работает быстрее и её данные более точные, если вы хотите выполнить просмотр открытых портов это не имеет большого значения. Опции у неё такие же

Программа `Nmap` - мощный сетевой сканер, разработанный для сканирования и тестирования на проникновение удаленных узлов, но ничего не мешает направить его на локальный компьютер. Утилита позволяет не только посмотреть открытые порты, но и примерно определить какие сервисы их слушают и какие уязвимости у них есть. Программа `Zenmap` - это графический интерфейс для nmap.

https://losst.ru/kak-posmotret-otkrytye-porty-v-linux
https://habr.com/ru/company/ruvds/blog/417485/

===================================================================
## Как проверить, есть ли обращение клиента на порт TCP 22 сервера по определенному порту с определенного IP адреса?


===================================================================
## В каком файле Linux прописывается монтирование разделов?
 Конфигурационный файл /etc/[fstab](https://help.ubuntu.ru/manual/fstab#%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BBetcfstab)
 
===================================================================
## Был ли опыт конфигурирования Nginx, почему его используют как точку входа перед Backend?


===================================================================
## Можно ли удалить default.conf из Nginx, в чем его ключевая фишка?


===================================================================
## Где локально в Linux прописать соответствие IP - DNS, как это может помочь в отладке конфигурации Nginx?
Откройте файл /etc/hosts используя любой текстовый редактор:
```
sudo gedit /etc/hosts
```
Добавьте в этот файл строки в формате:
```
IP_1    имя_хоста_1 короткое_имя
IP_2    имя_хоста_2
IP_3    имя_хоста_3
```
Например:
```
192.168.1.60    kali.hackware.lan   kali
192.168.1.70    mint.hackware.lan   mint
```
Сохраните и закройте файл.
Изменения, внесённые в файл hosts, вступают в силу немедленно.
https://zalinux.ru/?p=2819

===================================================================
## Где посмотреть сразу все настройки crontab разных пользователей в Linux?
```
for user in $(cut -d':' -f1 /etc/passwd); do crontab -u $user -l; done
```
https://blog.programs74.ru/how-to-get-all-cron-tasks-for-all-linux-user/

===================================================================
## В чем принципиальное отличие виртуализации от контейнерезации?
Отличие виртуальной машины от контейнера. Главное отличие ― способ работы. При виртуализации создается полностью отдельная операционная система. При контейнеризации используется ядро операционной системы той машины, на которой открывается контейнер.

https://www.itc.by/kontejnery-i-virtualnye-mashiny-v-chem-klyuchevye-razlichiya/

===================================================================
## Что такое Namespace в Linux, какие типы неймспейсов бывают?
Linux namespace – это абстракция над ресурсами в операционной системе. Мы можем думать об namespace, как о ящике. В этом ящике находятся системные ресурсы, которые точно зависят от типа ящика (namespace). В настоящее время существует семь типов пространств имён (namespaces): Cgroups, IPC, Network, Mount, PID, User, UTS.
Пространство имён	Что изолирует
PID	PID процессов
NETWORK	Сетевые устройства, стеки, порты и т.п.
USER	ID пользователей и групп
MOUNT	Точки монтирования
IPC	SystemV IPC, очереди сообщений POSIX
UTS	Имя хоста и доменное имя NIS

Пространство имён (от англ. namespaces) — это функция ядра Linux, позволяющая изолировать и виртуализировать глобальные системные ресурсы множества процессов. Примеры ресурсов, которые можно виртуализировать: ID процессов, имена хостов, ID пользователей, доступ к сетям, межпроцессное взаимодействие и файловые системы. Одной из общих целей пространств имён является поддержка реализации контейнеров — инструмента для виртуализации на уровне операционной системы (а также других целей), обеспечивающего группу процессов иллюзией того, что они являются единственными процессами в системе. Поэтому одной из главных целей пространства имён является поддержка контейнеризации в Linux[1].
Пространства имён Linux возникли в 2002 году в версии ядра 2.4.19[1]. Дополнительные пространства имён были добавлены в 2006 году и продолжали добавляться в будущем. Достаточная функциональность для полной изоляции и безопасной работы контейнеров была завершена в ядре версии 3.8 с введением пространств имён пользователей[3].

https://habr.com/ru/post/458462/
https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%B8%D0%BC%D1%91%D0%BD_(Linux)
https://selectel.ru/blog/mexanizmy-kontejnerizacii-namespaces/
